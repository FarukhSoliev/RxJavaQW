Отчет о реализации реактивной библиотеки
Этот отчет предоставляет подробное описание архитектуры, принципов работы, особенностей реализации и процесса тестирования разработанной реактивной библиотеки, вдохновленной RxJava.

1. Архитектура системы
Архитектура реализованной системы основана на следующих ключевых компонентах:

Observer<T> (Наблюдатель): Интерфейс, определяющий методы обратного вызова для обработки данных (onNext), ошибок (onError) и завершения потока (onComplete). Наблюдатели подписываются на Observable и получают уведомления об изменениях в потоке данных.
Observable<T> (Наблюдаемый): Класс, представляющий собой поток данных, который может быть наблюдаемым. Он предоставляет методы для создания, преобразования и фильтрации данных, а также для подписки наблюдателей. Observable является сердцем реактивной системы.
Disposable (Утилизация): Интерфейс, позволяющий отменить подписку. Подписка возвращает объект Disposable, который можно использовать для отмены подписки. Это важно для предотвращения утечек памяти и остановки ненужных операций.
Scheduler (Планировщик): Интерфейс, определяющий, как должны выполняться задачи. Scheduler отвечает за управление потоками и асинхронностью.
Операторы: Методы класса Observable, которые позволяют преобразовывать, фильтровать и комбинировать потоки данных. Примеры: map, filter, flatMap, subscribeOn, observeOn.
ObservableSource (Источник данных): Функциональный интерфейс, представляющий собой источник данных для Observable. Содержит один метод subscribe(), который принимает Observer. Это позволяет отделить логику создания Observable от логики подписки на него.
Subscription (Подписка): Внутренний класс, который реализует Observer и Disposable. Он управляет фактической подпиской и обеспечивает возможность отмены.
Взаимодействие компонентов:

Создание Observable: Observable создается с помощью статического метода create(), который принимает ObservableSource.
Подписка на Observable: Observer подписывается на Observable с помощью метода subscribe(). Этот метод возвращает объект Disposable, позволяющий отменить подписку.
Эмиссия данных: ObservableSource (источник данных) эмитирует данные, вызывая методы onNext(), onError() и onComplete() у Observer.
Преобразование и фильтрация: Операторы преобразуют и фильтруют данные, создавая новые Observable, которые передают данные наблюдателю.
Управление потоками: Операторы subscribeOn() и observeOn() позволяют управлять потоками, в которых выполняются операции.
Отмена подписки: Disposable позволяет отменить подписку и остановить поток данных.
2. Принципы работы Schedulers
Scheduler — это интерфейс, который определяет, как должны выполняться задачи. Он предоставляет абстракцию над управлением потоками и позволяет выполнять задачи асинхронно.

Реализованы следующие типы Scheduler:

IOThreadScheduler: Использует CachedThreadPool. Подходит для задач, связанных с вводом-выводом (сеть, файлы, базы данных). Потоки создаются по мере необходимости и переиспользуются, что позволяет эффективно использовать ресурсы. CachedThreadPool хорошо подходит для обработки большого количества кратковременных задач.
ComputationScheduler: Использует FixedThreadPool. Предназначен для вычислительных задач, требующих интенсивного использования процессора. Количество потоков ограничено количеством ядер процессора, что позволяет избежать перегрузки системы.
SingleThreadScheduler: Использует SingleThreadExecutor. Гарантирует, что задачи будут выполняться последовательно в одном потоке. Подходит для задач, требующих строгой последовательности выполнения или доступа к ресурсам, не поддерживающим многопоточный доступ.
Различия и области применения:

| Scheduler | Тип пула | | SingleThreadScheduler| SingleThreadExecutor| Задачи, требующие строгой последовательности выполнения. Доступ к ресурсам, не поддерживающим многопоточный доступ. Управление состоянием в одном потоке. |

Операторы subscribeOn() и observeOn():

subscribeOn(Scheduler scheduler): Указывает, в каком потоке будет выполняться подписка на Observable. Это определяет, в каком потоке будет создан источник данных и начнут генерироваться данные.
observeOn(Scheduler scheduler): Указывает, в каком потоке будут вызываться методы onNext(), onError() и onComplete() у Observer. Это позволяет переключить поток для обработки данных, полученных из Observable.
Пример использования:

java

Observable.create(observer -> {
    //  Создание данных (выполняется в потоке, указанном в subscribeOn)
    observer.onNext("Hello");
    observer.onComplete();
})
.subscribeOn(new Observable.IOThreadScheduler())  //  Подписка выполняется в IO потоке
.observeOn(new Observable.ComputationScheduler()) //  Обработка выполняется в Computation потоке
.subscribe(item -> {
    //  Обработка данных (выполняется в потоке, указанном в observeOn)
    System.out.println(item);
});
3. Процесс тестирования
Процесс тестирования включал модульное тестирование (unit testing) с использованием JUnit. Использовались моки (Mockito) для изоляции тестируемых компонентов.

Основные сценарии тестирования:

Базовые компоненты:
Проверка вызова методов onNext(), onError() и onComplete() у Observer.
Проверка создания Observable с помощью метода create().
Проверка обработки исключений при создании Observable.
Операторы:
Проверка корректной работы операторов map(), filter() и flatMap().
Проверка обработки ошибок, возникающих в операторах.
Проверка правильности преобразования и фильтрации данных.
Schedulers:
Проверка корректного выполнения задач в разных потоках с использованием subscribeOn() и observeOn().
Проверка того, что задачи выполняются в потоках, соответствующих выбранному Scheduler (IO, Computation, SingleThread).
Проверка правильной работы с многопоточной средой.
Управление подписками:
Проверка возможности отмены подписки с помощью метода dispose().
Проверка того, что после отмены подписки, Observer больше не получает уведомления.
Обработка ошибок:
Проверка того, что ошибки правильно передаются в метод onError() у Observer.
Проверка, что после получения ошибки, поток завершается.
Покрытие тестами:

Тестами были покрыты основные сценарии использования каждого компонента системы. Это позволило убедиться в корректности работы и надежности библиотеки.

4. Примеры использования
Пример 1: Преобразование списка чисел:

java

Observable.create(observer -> {
    Arrays.asList(1, 2, 3, 4, 5).forEach(observer::onNext);
    observer.onComplete();
})
.map(x -> x * 2) // Умножение каждого числа на 2
.filter(x -> x > 5) // Фильтрация чисел больше 5
.subscribe(System.out::println);
Пример 2: Асинхронный запрос к базе данных:

java

Observable.create(observer -> {
    // Имитация запроса к базе данных
    new Thread(() -> {
        try {
            Thread.sleep(100);
            String data = "Данные из базы данных";
            observer.onNext(data);
            observer.onComplete();
        } catch (InterruptedException e) {
            observer.onError(e);
        }
    }).start();
})
.subscribeOn(new Observable.IOThreadScheduler()) // Выполнение запроса в IO потоке
.subscribe(data -> {
    System.out.println("Получены данные: " + data);
});
Пример 3: Обработка событий в графическом интерфейсе: (Консольный пример, имитирующий UI)

java

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Observable.SingleThreadScheduler uiScheduler = new Observable.SingleThreadScheduler();
        Scanner scanner = new Scanner(System.in);

        Observable<String> userInputObservable = Observable.create(observer -> {
            while (true) {
                System.out.println("Enter text (or 'exit' to quit):");
                String input = scanner.nextLine();
                observer.onNext(input);
                if ("exit".equalsIgnoreCase(input)) {
                    observer.onComplete();
                    break;
                }
            }
        });

        userInputObservable
                .observeOn(uiScheduler) // UI thread
                .subscribe(text -> {
                    System.out.println("You entered: " + text + " (processed on UI thread)");
                }, Throwable::printStackTrace, () -> {
                    System.out.println("Exiting the application.");
                    uiScheduler.shutdown();
                });
    }
}
Эти примеры демонстрируют основные возможности реализованной библиотеки и то, как ее можно использовать для решения различных задач, от простых преобразований данных до асинхронной обработки и управления потоками.
